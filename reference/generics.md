---
title: 'ジェネリクス | リファレンス'
description: ''
---

# ジェネリクス

ジェネリクスは、異なる入力データ型に対して関数と構造体を定義するために使用できます。この言語機能は時々パラメトリック多相性と呼ばれます。Moveでは、ジェネリクスという用語を_型パラメータ_と_型引数_と交換可能に使用することがよくあります。

ジェネリクスは、[vector](./primitive-types/vector)などのライブラリコードで一般的に使用され、任意の可能な型（指定された制約を満たす）で動作するコードを宣言します。この種のパラメータ化により、複数の型と状況で同じ実装を再利用できます。

## 型パラメータの宣言

関数と構造体の両方は、角括弧`<...>`で囲まれた型パラメータのリストをシグネチャに取ることができます。

### ジェネリック関数

関数の型パラメータは、関数名の後、値パラメータリストの前に配置されます。以下のコードは、任意の型の値を受け取り、その値を変更せずに返すジェネリック恒等関数を定義しています。

```move
fun id<T>(x: T): T {
    // この型注釈は不要ですが有効です
    (x: T)
}
```

一度定義されると、型パラメータ`T`はパラメータ型、戻り値の型、関数本体内で使用できます。

### ジェネリック構造体

構造体の型パラメータは構造体名の後に配置され、フィールドの型を命名するために使用できます。

```move
public struct Foo<T> has copy, drop { x: T }

public struct Bar<T1, T2> has copy, drop {
    x: T1,
    y: vector<T2>,
}
```

[型パラメータは使用する必要がない](#unused-type-parameters)ことに注意してください

## 型引数

### ジェネリック関数の呼び出し

ジェネリック関数を呼び出す際は、角括弧で囲まれたリストで関数の型パラメータの型引数を指定できます。

```move
fun foo() {
    let x = id<bool>(true);
}
```

型引数を指定しない場合、Moveの[型推論](#type-inference)がそれらを提供します。

### ジェネリック構造体の使用

同様に、ジェネリック型の値を構築または破棄する際に、構造体の型パラメータの型引数リストを添付できます。

```move
fun foo() {
    // 構築時の型引数
    let foo = Foo<bool> { x: true };
    let bar = Bar<u64, u8> { x: 0, y: vector<u8>[] };

    // 破棄時の型引数
    let Foo<bool> { x } = foo;
    let Bar<u64, u8> { x, y } = bar;
}
```

いずれの場合も型引数を指定しない場合、Moveの[型推論](#type-inference)がそれらを提供します。

### 型引数の不一致

型引数を指定し、それらが提供された実際の値と競合する場合、エラーが発生します：

```move
fun foo() {
    let x = id<u64>(true); // ERROR! trueはu64ではありません
}
```

同様に：

```move
fun foo() {
    let foo = Foo<bool> { x: 0 }; // ERROR! 0はboolではありません
    let Foo<address> { x } = foo; // ERROR! boolはaddressと互換性がありません
}
```

## 型推論

ほとんどの場合、Moveコンパイラは型引数を推論できるため、明示的に記述する必要はありません。型引数を省略した場合の上記の例は以下のようになります：

```move
fun foo() {
    let x = id(true);
    //        ^ <bool>が推論されます

    let foo = Foo { x: true };
    //           ^ <bool>が推論されます

    let Foo { x } = foo;
    //     ^ <bool>が推論されます
}
```

注意：コンパイラが型を推論できない場合、手動で注釈する必要があります。一般的なシナリオは、型パラメータが戻り値の位置にのみ現れる関数を呼び出すことです。

```move
module a::m;

fun foo() {
    let v = vector[]; // ERROR!
    //            ^ コンパイラは要素型を把握できません。使用されていないためです

    let v = vector<u64>[];
    //            ^~~~~ この場合は手動で注釈する必要があります。
}
```

これらのケースは`vector[]`が使用されないため少し人工的であり、そのためMoveの型推論は型を推論できません。

ただし、その値がその関数内で後で使用される場合、コンパイラは型を推論できます：

```move
module a::m;

fun foo() {
    let v = vector[];
    //            ^ <u64>が推論されます
    vector::push_back(&mut v, 42);
    //               ^ <u64>が推論されます
}
```

### `_`型

場合によっては、型引数の一部を明示的に注釈し、他の部分をコンパイラに推論させたいことがあります。`_`型は、コンパイラが型を推論するためのプレースホルダーとして機能します。

```move
let bar = Bar<u64, _> { x: 0, y: vector[b"hello"] };
//                 ^ vector<u8>が推論されます
```

プレースホルダー`_`は、シグネチャではなく、式とマクロ関数定義でのみ現れることができます。これは、関数パラメータ、関数戻り値の型、定数定義型、データ型フィールドの定義の一部として`_`を使用できないことを意味します。

## 整数

Moveでは、整数型`u8`、`u16`、`u32`、`u64`、`u128`、`u256`はすべて異なる型です。ただし、これらの型のそれぞれは同じ数値構文で作成できます。言い換えると、型サフィックスが提供されない場合、コンパイラは値の使用に基づいて整数型を推論します。

```move
let x8: u8 = 0;
let x16: u16 = 0;
let x32: u32 = 0;
let x64: u64 = 0;
let x128: u128 = 0;
let x256: u256 = 0;
```

値が特定の整数型を必要とするコンテキストで使用されない場合、`u64`がデフォルトとして使用されます。

```move
let x = 0;
//      ^ デフォルトでu64が使用されます
```

ただし、値が推論された型に対して大きすぎる場合、エラーが発生します

```move
let i: u8 = 256; // ERROR!
//          ^^^ u8には大きすぎます
let x = 340282366920938463463374607431768211454;
//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ u64には大きすぎます
```

数値が大きすぎる場合、明示的に注釈する必要があるかもしれません

```move
let x = 340282366920938463463374607431768211454u128;
//                                             ^^^^ 有効です！
```

## 未使用の型パラメータ

構造体定義では、未使用の型パラメータは、構造体で定義されたフィールドに現れないが、コンパイル時に静的にチェックされるものです。Moveは未使用の型パラメータを許可するため、以下の構造体定義は有効です：

```move
public struct Foo<T> {
    foo: u64
}
```

これは特定の概念をモデル化する際に便利です。以下に例を示します：

```move
module a::m;

// 通貨指定子
public struct A {}
public struct B {}

// 通貨指定子型を使用してインスタンス化できるジェネリックコイン型
//   例：Coin<A>、Coin<B>など
public struct Coin<Currency> has store {
    value: u64
}

// すべての通貨について汎用的にコードを書く
public fun mint_generic<Currency>(value: u64): Coin<Currency> {
    Coin { value }
}

// 特定の通貨について具体的にコードを書く
public fun mint_a(value: u64): Coin<A> {
    mint_generic(value)
}
public fun mint_b(value: u64): Coin<B> {
    mint_generic(value)
}
```

この例では、`Coin<Currency>`は`Currency`型パラメータでジェネリックであり、コインの通貨を指定し、任意の通貨について汎用的に、または特定の通貨について具体的にコードを書くことを可能にします。この汎用性は、`Currency`型パラメータが`Coin`で定義されたフィールドに現れない場合でも適用されます。

### ファントム型パラメータ

上記の例では、`struct Coin`が`store`アビリティを要求しているにもかかわらず、`Coin<A>`も`Coin<B>`も`store`アビリティを持ちません。これは、[条件付きアビリティとジェネリック型](./abilities#conditional-abilities-and-generic-types)のルールと、`A`と`B`が`store`アビリティを持たないという事実によるものです。`struct Coin`の本体で使用されていないにもかかわらずです。これにより、いくつかの不快な結果が生じる可能性があります。例えば、`Coin<A>`をストレージのウォレットに入れることができません。

一つの可能な解決策は、`A`と`B`に偽のアビリティ注釈を追加することです（例：`public struct Currency1 has store {}`）。しかし、これは不要なアビリティ宣言で型を弱体化させるため、バグやセキュリティの脆弱性につながる可能性があります。例えば、ストレージの値が`A`型のフィールドを持つことを期待することはありませんが、偽の`store`アビリティがあれば可能になります。さらに、偽の注釈は感染性があり、未使用の型パラメータでジェネリックな多くの関数も必要な制約を含める必要があります。

ファントム型パラメータはこの問題を解決します。未使用の型パラメータは_ファントム_型パラメータとしてマークでき、構造体のアビリティ導出に参加しません。この方法で、ジェネリック型のアビリティを導出する際にファントム型パラメータへの引数は考慮されないため、偽のアビリティ注釈の必要性を回避できます。この緩和されたルールが健全であるため、Moveの型システムは、`phantom`として宣言されたパラメータが構造体定義で全く使用されないか、`phantom`として宣言された型パラメータへの引数としてのみ使用されることを保証します。

#### 宣言

構造体定義では、型パラメータを宣言の前に`phantom`キーワードを追加することでファントムとして宣言できます。

```move
public struct Coin<phantom Currency> has store {
    value: u64
}
```

型パラメータがファントムとして宣言されている場合、それをファントム型パラメータと呼びます。構造体を定義する際、Moveの型チェッカーは、すべてのファントム型パラメータが構造体定義内で使用されないか、ファントム型パラメータへの引数としてのみ使用されることを保証します。

```move
public struct S1<phantom T1, T2> { f: u64 }
//               ^^^^^^^ 有効、T1は構造体定義内に現れません

public struct S2<phantom T1, T2> { f: S1<T1, T2> }
//               ^^^^^^^ 有効、T1はファントム位置に現れます
```

以下のコードは、ルールの違反例を示しています：

```move
public struct S1<phantom T> { f: T }
//               ^^^^^^^ ERROR!  ^ ファントム位置ではありません

public struct S2<T> { f: T }
public struct S3<phantom T> { f: S2<T> }
//               ^^^^^^^ ERROR!     ^ ファントム位置ではありません
```

より正式には、型がファントム型パラメータへの引数として使用される場合、その型は_ファントム位置_に現れると言います。この定義により、ファントムパラメータの正しい使用のルールは以下のように指定できます：**ファントム型パラメータはファントム位置にのみ現れることができます**。

`phantom`の指定は必須ではありませんが、型パラメータが`phantom`になる可能性があるがマークされていない場合、コンパイラは警告を出します。

#### インスタンス化

構造体をインスタンス化する際、ファントムパラメータへの引数は構造体のアビリティを導出する際に除外されます。例えば、以下のコードを考えてみてください：

```move
public struct S<T1, phantom T2> has copy { f: T1 }
public struct NoCopy {}
public struct HasCopy has copy {}
```

`S<HasCopy, NoCopy>`型を考えてみてください。`S`は`copy`で定義されており、すべての非ファントム引数が`copy`を持つため、`S<HasCopy, NoCopy>`も`copy`を持ちます。

#### アビリティ制約を持つファントム型パラメータ

アビリティ制約とファントム型パラメータは、ファントムパラメータがアビリティ制約で宣言できるという意味で直交する機能です。

```move
public struct S<phantom T: copy> {}
```

アビリティ制約を持つファントム型パラメータをインスタンス化する際、パラメータがファントムであっても、型引数はその制約を満たす必要があります。通常の制限が適用され、`T`は`copy`を持つ引数でのみインスタンス化できます。

## 制約

上記の例では、型パラメータを使用して「未知の」型を定義し、後で呼び出し元がプラグインできる方法を示しました。しかし、これは型システムが型についてほとんど情報を持たず、非常に保守的な方法でチェックを実行する必要があることを意味します。ある意味で、型システムは制約のないジェネリックに対して最悪のシナリオを想定する必要があります—[アビリティ](./abilities)を持たない型です。

制約は、これらの未知の型が持つプロパティを指定する方法を提供し、型システムがそうでなければ安全でない操作を許可できるようにします。

### 制約の宣言

制約は以下の構文を使用して型パラメータに課すことができます。

```move
// Tは型パラメータの名前です
T: <ability> (+ <ability>)*
```

`<ability>`は4つの[アビリティ](./abilities)のいずれかであり、型パラメータは一度に複数のアビリティで制約できます。したがって、以下はすべて有効な型パラメータ宣言です：

```move
T: copy
T: copy + drop
T: copy + drop + store + key
```

### 制約の検証

制約はインスタンス化サイトでチェックされます

```move
public struct Foo<T: copy> { x: T }

public struct Bar { x: Foo<u8> }
//                         ^^ 有効、u8は`copy`を持ちます

public struct Baz<T> { x: Foo<T> }
//                            ^ ERROR! Tは'copy'を持ちません
```

関数についても同様です

```move
fun unsafe_consume<T>(x: T) {
    // ERROR! xは'drop'を持ちません
}

fun consume<T: drop>(x: T) {
    // 有効、xは自動的にドロップされます
}

public struct NoAbilities {}

fun foo() {
    let r = NoAbilities {};
    consume<NoAbilities>(NoAbilities);
    //      ^^^^^^^^^^^ ERROR! NoAbilitiesは'drop'を持ちません
}
```

`copy`を使った同様の例もいくつかあります

```move
fun unsafe_double<T>(x: T) {
    (copy x, x)
    // ERROR! Tは'copy'を持ちません
}

fun double<T: copy>(x: T) {
    (copy x, x) // 有効、Tは'copy'を持ちます
}

public struct NoAbilities {}

fun foo(): (NoAbilities, NoAbilities) {
    let r = NoAbilities {};
    double<NoAbilities>(r)
    //     ^ ERROR! NoAbilitiesは'copy'を持ちません
}
```

詳細については、[条件付きアビリティとジェネリック型](./abilities#conditional-abilities-and-generic-types)のアビリティセクションを参照してください。

## 再帰の制限

### 再帰構造体

ジェネリック構造体は、異なる型引数であっても、同じ型のフィールドを直接または間接的に含むことはできません。以下の構造体定義はすべて無効です：

```move
public struct Foo<T> {
    x: Foo<u64> // ERROR! 'Foo'を含む'Foo'
}

public struct Bar<T> {
    x: Bar<T> // ERROR! 'Bar'を含む'Bar'
}

// ERROR! 'A'と'B'が循環を形成し、これも許可されません。
public struct A<T> {
    x: B<T, u64>
}

public struct B<T1, T2> {
    x: A<T1>
    y: A<T2>
}
```

### 高度なトピック: 型レベル再帰

Moveはジェネリック関数の再帰呼び出しを許可します。ただし、ジェネリック構造体と組み合わせて使用すると、特定のケースで無限の数の型を作成する可能性があり、これを許可することは、コンパイラ、VM、その他の言語コンポーネントに不要な複雑さを追加することを意味します。したがって、そのような再帰は禁止されています。

この制限は将来緩和される可能性がありますが、今のところ、以下の例は何が許可され、何が許可されないかの理解を提供するはずです。

```move
module a::m;

public struct A<T> {}

// 有限の数の型 -- 許可されます。
// foo<T> -> foo<T> -> foo<T> -> ... は有効です
fun foo<T>() {
    foo<T>();
}

// 有限の数の型 -- 許可されます。
// foo<T> -> foo<A<u64>> -> foo<A<u64>> -> ... は有効です
fun foo<T>() {
    foo<A<u64>>();
}
```

許可されないもの：

```move
module a::m;

public struct A<T> {}

// 無限の数の型 -- 許可されません。
// エラー！
// foo<T> -> foo<A<T>> -> foo<A<A<T>>> -> ...
fun foo<T>() {
    foo<Foo<T>>();
}
```

同様に、許可されません：

```move
module a::n;

public struct A<T> {}

// 無限の数の型 -- 許可されません。
// エラー！
// foo<T1, T2> -> bar<T2, T1> -> foo<T2, A<T1>>
//   -> bar<A<T1>, T2> -> foo<A<T1>, A<T2>>
//   -> bar<A<T2>, A<T1>> -> foo<A<T2>, A<A<T1>>>
//   -> ...
fun foo<T1, T2>() {
    bar<T2, T1>();
}

fun bar<T1, T2> {
    foo<T1, A<T2>>();
}
```

注意：型レベル再帰のチェックは、呼び出しサイトでの保守的な分析に基づいており、制御フローやランタイム値は考慮しません。

```move
module a::m;

public struct A<T> {}

// 無限の数の型 -- 許可されません。
// エラー！
fun foo<T>(n: u64) {
    if (n > 0) foo<A<T>>(n - 1);
}
```

上記の例の関数は技術的には任意の入力に対して終了し、したがって有限の数の型のみを作成しますが、Moveの型システムでは依然として無効と見なされます。
