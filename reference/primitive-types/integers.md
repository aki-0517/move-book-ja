---
title: '整数 | リファレンス'
description: ''
---

# 整数

Moveは6つの符号なし整数型をサポートします：`u8`、`u16`、`u32`、`u64`、`u128`、`u256`。これらの型の値は0から型のサイズに依存する最大値までの範囲です。

| Type                             | Value Range              |
| -------------------------------- | ------------------------ |
| Unsigned 8-bit integer, `u8`     | 0 to 2<sup>8</sup> - 1   |
| Unsigned 16-bit integer, `u16`   | 0 to 2<sup>16</sup> - 1  |
| Unsigned 32-bit integer, `u32`   | 0 to 2<sup>32</sup> - 1  |
| Unsigned 64-bit integer, `u64`   | 0 to 2<sup>64</sup> - 1  |
| Unsigned 128-bit integer, `u128` | 0 to 2<sup>128</sup> - 1 |
| Unsigned 256-bit integer, `u256` | 0 to 2<sup>256</sup> - 1 |

## リテラル

これらの型のリテラル値は、数字のシーケンス（例：`112`）または16進リテラル（例：`0xFF`）として指定されます。リテラルの型は、オプションでサフィックスとして追加できます（例：`112u8`）。型が指定されていない場合、コンパイラはリテラルが使用されるコンテキストから型を推論しようとします。型を推論できない場合、`u64`と仮定されます。

数値リテラルは、グループ化と可読性のためにアンダースコアで区切ることができます（例：`1_234_5678`、`1_000u128`、`0xAB_CD_12_35`）。

リテラルが指定された（または推論された）サイズ範囲に対して大きすぎる場合、エラーが報告されます。

### 例

```move
// 明示的な注釈付きリテラル
let explicit_u8 = 1u8;
let explicit_u16 = 1u16;
let explicit_u32 = 1u32;
let explicit_u64 = 2u64;
let explicit_u128 = 3u128;
let explicit_u256 = 1u256;
let explicit_u64_underscored = 154_322_973u64;

// シンプルな推論付きリテラル
let simple_u8: u8 = 1;
let simple_u16: u16 = 1;
let simple_u32: u32 = 1;
let simple_u64: u64 = 2;
let simple_u128: u128 = 3;
let simple_u256: u256 = 1;

// より複雑な推論付きリテラル
let complex_u8 = 1; // 推論: u8
// シフトの右側引数はu8でなければならない
let _unused = 10 << complex_u8;

let x: u8 = 38;
let complex_u8 = 2; // 推論: u8
// `+`の引数は同じ型でなければならない
let _unused = x + complex_u8;

let complex_u128 = 133_876; // 推論: u128
// 関数引数の型から推論
function_that_takes_u128(complex_u128);

// リテラルは16進数で書くことができる
let hex_u8: u8 = 0x1;
let hex_u16: u16 = 0x1BAE;
let hex_u32: u32 = 0xDEAD80;
let hex_u64: u64 = 0xCAFE;
let hex_u128: u128 = 0xDEADBEEF;
let hex_u256: u256 = 0x1123_456A_BCDE_F;
```

## 操作

### 算術演算

これらの型はすべて、同じチェック付き算術演算セットをサポートしています。これらの演算すべてにおいて、両方の引数（左側と右側のオペランド）は_同じ型_でなければなりません。異なる型の値に対して演算を行う必要がある場合は、まず[キャスト](#casting)を実行する必要があります。同様に、演算の結果が整数型に対して大きすぎると予想される場合は、演算を実行する前に[キャスト](#casting)をより大きなサイズに実行してください。

すべての算術演算は、数学的整数が行わない動作（例：オーバーフロー、アンダーフロー、ゼロ除算）をする代わりにアボートします。

| 構文 | 演算           | アボート条件                                |
| ------ | ------------------- | ---------------------------------------- |
| `+`    | 加算            | 結果が整数型に対して大きすぎる |
| `-`    | 減算         | 結果がゼロ未満                 |
| `*`    | 乗算      | 結果が整数型に対して大きすぎる |
| `%`    | モジュラー除算    | 除数が`0`                       |
| `/`    | 切り捨て除算 | 除数が`0`                       |

### ビット演算

整数型は、数値の整数値としてではなく、各数値を0または1の個別ビットのシリーズとして扱う以下のビット演算をサポートします。

ビット演算はアボートしません。

| 構文              | 演算   | 説明                                           |
| ------------------- | ----------- | ----------------------------------------------------- |
| `&`                 | ビットAND | 各ビットペアに対してブールANDを実行          |
| <code>&#124;</code> | ビットOR  | 各ビットペアに対してブールORを実行           |
| `^`                 | ビットXOR | 各ビットペアに対してブール排他的ORを実行 |

### ビットシフト

ビット演算と同様に、各整数型はビットシフトをサポートします。しかし、他の演算とは異なり、右側のオペランド（シフトするビット数）は_常に_`u8`でなければならず、左側のオペランド（シフトする数）と一致する必要はありません。

シフトするビット数が`u8`、`u16`、`u32`、`u64`、`u128`、`u256`に対してそれぞれ`8`、`16`、`32`、`64`、`128`、`256`以上の場合、ビットシフトはアボートする可能性があります。

| 構文 | 演算   | アボート条件                                                               |
| ------ | ----------- | ----------------------------------------------------------------------- |
| `<<`   | 左シフト  | シフトするビット数が整数型のサイズより大きい |
| `>>`   | 右シフト | シフトするビット数が整数型のサイズより大きい |

### 比較

整数型は、Moveで比較演算子を使用できる_唯一の_型です。両方の引数は同じ型である必要があります。異なる型の整数を比較する必要がある場合は、まずそのうちの1つを[キャスト](#casting)する必要があります。

比較演算はアボートしません。

| 構文 | 演算                |
| ------ | ------------------------ |
| `<`    | より小さい                |
| `>`    | より大きい             |
| `<=`   | 以下    |
| `>=`   | 以上 |

### 等価性

[`drop`](./../abilities)を持つすべての型と同様に、すべての整数型は["等しい"](./../equality)と["等しくない"](./../equality)の演算をサポートします。両方の引数は同じ型である必要があります。異なる型の整数を比較する必要がある場合は、まずそのうちの1つを[キャスト](#casting)する必要があります。

等価性演算はアボートしません。

| 構文 | 演算 |
| ------ | --------- |
| `==`   | 等しい     |
| `!=`   | 等しくない |

詳細については、[等価性](./../equality)のセクションを参照してください

## キャスト

1つのサイズの整数型は、別のサイズの整数型にキャストできます。整数は、Moveでキャストをサポートする唯一の型です。

キャストは_切り捨てません_。結果が指定された型に対して大きすぎる場合、キャストはアボートします。

| 構文     | 演算                                            | アボート条件                              |
| ---------- | ---------------------------------------------------- | -------------------------------------- |
| `(e as T)` | 整数式`e`を整数型`T`にキャスト | `e`が`T`として表現するには大きすぎる |

ここで、`e`の型は`8`、`16`、`32`、`64`、`128`、または`256`でなければならず、`T`は`u8`、`u16`、`u32`、`u64`、`u128`、または`u256`でなければなりません。

例：

- `(x as u8)`
- `(y as u16)`
- `(873u16 as u32)`
- `(2u8 as u64)`
- `(1 + 3 as u128)`
- `(4/2 + 12345 as u256)`

## 所有権

言語に組み込まれた他のスカラー値と同様に、整数値は暗黙的にコピー可能です。これは、[`copy`](./../variables#move-and-copy)などの明示的な命令なしにコピーできることを意味します。
