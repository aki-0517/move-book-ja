# パターン：ケーパビリティ

プログラミングにおいて、_ケーパビリティ_は、所有者に特定のアクションを実行する権利を与える
トークンです。これは、リソースと操作へのアクセスを制御するために使用されるパターンです。
ケーパビリティの簡単な例は、ドアの鍵です。鍵を持っていれば、ドアを開けることができます。
鍵を持っていなければ、ドアを開けることができません。より実用的な例は、所有者が
通常のユーザーができない管理操作を実行することを可能にするAdmin Capabilityです。

## ケーパビリティはオブジェクト

[Sui Object Model](./../object/)では、ケーパビリティはオブジェクトとして表現されます。
オブジェクトの所有者は、このオブジェクトを関数に渡して、特定のアクションを実行する権利を
持っていることを証明できます。厳密な型付けにより、ケーパビリティを引数として取る関数は
正しいケーパビリティでのみ呼び出すことができます。

> ケーパビリティには`Cap`サフィックスを付ける慣例があります。例えば、`AdminCap`や
> `KioskOwnerCap`です。

```move file=packages/samples/sources/programmability/capability.move anchor=main

```

## Admin Capabilityに`init`を使用する

非常に一般的な実践は、パッケージ公開時に単一の`AdminCap`オブジェクトを作成することです。
このようにして、アプリケーションは管理者アカウントがアプリケーションの状態を準備する
セットアップフェーズを持つことができます。

```move file=packages/samples/sources/programmability/capability-2.move anchor=admin_cap

```

## アドレスチェック vs ケーパビリティ

オブジェクトをケーパビリティとして使用することは、ブロックチェーンプログラミングでは
比較的新しい概念です。他のスマートコントラクト言語では、認証は送信者のアドレスを
チェックすることで行われることがよくあります。このパターンはSuiでも有効ですが、
全体的な推奨事項は、より良いセキュリティ、発見可能性、コード組織のために
ケーパビリティを使用することです。

ユーザーを作成する`new`関数がアドレスチェックを使用していた場合の様子を見てみましょう：

```move file=packages/samples/sources/programmability/capability-3.move anchor=with_address

```

そして今度は、同じ関数がケーパビリティを使用した場合の様子を見てみましょう：

```move file=packages/samples/sources/programmability/capability-4.move anchor=with_capability

```

ケーパビリティを使用することには、アドレスチェックよりもいくつかの利点があります：

- ケーパビリティはオブジェクトであるため、管理者権限の移行が容易です。アドレスの場合、
  管理者アドレスが変更されると、アドレスをチェックするすべての関数を更新する必要があります
  - したがって、パッケージアップグレードが必要です。
- ケーパビリティを使用すると、関数シグネチャがより説明的になります。`new`関数が
  `AdminCap`を引数として渡す必要があることが明確です。そして、この関数はそれなしでは
  呼び出すことができません。
- オブジェクトケーパビリティは関数本体で追加のチェックを必要としないため、
  開発者のミスの可能性を減らします。
- 所有されたケーパビリティは発見にも役立ちます。AdminCapの所有者は、アカウント内の
  オブジェクト（ウォレットやエクスプローラー経由）を見て、管理者権限を持っていることを
  知ることができます。これはアドレスチェックではそれほど透明ではありません。

ただし、アドレスアプローチにも独自の利点があります。例えば、アドレスがマルチシグで、
トランザクション構築がより複雑になる場合、アドレスをチェックする方が簡単かもしれません。
また、すべての関数で使用されるアプリケーションの中央オブジェクトがある場合、
管理者アドレスを保存でき、これにより移行が簡素化されます。中央オブジェクトアプローチは、
管理者がユーザーからケーパビリティを取り消すことができる取り消し可能なケーパビリティにも
価値があります。
