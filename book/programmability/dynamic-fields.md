# 動的フィールド

Sui Objectモデルでは、オブジェクトを他のオブジェクトに_動的フィールド_としてアタッチできます。
この動作は、他のプログラミング言語で`Map`がどのように動作するかと似ています。ただし、
Moveでは厳密に型付けされる`Map`（[Collections](./collections)セクションで説明しました）とは異なり、
動的フィールドは任意の型のオブジェクトをアタッチできます。フロントエンド開発の世界での
類似のアプローチは、任意の型のデータを動的に格納できるJavaScript Object型です。

> オブジェクトにアタッチできる動的フィールドの数に制限はありません。したがって、
> 動的フィールドは、オブジェクト制限サイズに収まらない大量のデータを格納するために
> 使用できます。

動的フィールドは、[オブジェクトサイズ制限](./../guides/building-against-limits)を回避するために
データを小さな部分に分割することから、アプリケーションロジックの一部としてオブジェクトを
アタッチすることまで、幅広いアプリケーションを可能にします。

## 定義

動的フィールドは[Sui Framework](./sui-framework)の`sui::dynamic_field`モジュールで定義されています。
これらは_名前_を介してオブジェクトの`UID`にアタッチされ、その名前を使用してアクセスできます。
指定された名前を持つフィールドは、オブジェクトに1つだけアタッチできます。

```move
module sui::dynamic_field;

/// フィールドと値を格納するために使用される内部オブジェクト
public struct Field<Name: copy + drop + store, Value: store> has key {
    /// オブジェクトID、フィールド名の値、その型のハッシュによって決定される
    /// つまり、hash(parent.id || name || Name)
    id: UID,
    /// このフィールドの名前の値
    name: Name,
    /// このフィールドにバインドされた値
    value: Value,
}
```

定義が示すように、動的フィールドは内部の`Field`オブジェクトに格納され、
オブジェクトID、フィールド名、フィールド型に基づいて決定的な方法で生成された`UID`を持ちます。
`Field`オブジェクトには、フィールド名とそれにバインドされた値が含まれています。
`Name`と`Value`型パラメータの制約は、キーと値が持つ必要があるアビリティを定義します。

## 使用法

動的フィールドで利用可能なメソッドは直接的です：フィールドは`add`で追加、`remove`で削除、
`borrow`と`borrow_mut`で読み取ることができます。さらに、`exists_`メソッドを使用して
フィールドが存在するかチェックできます（型によるより厳密なチェックには、
`exists_with_type`メソッドがあります）。

```move file=packages/samples/sources/programmability/dynamic-fields.move anchor=usage

```

上記の例では、`Character`オブジェクトと、ベクターに一緒に置くことができない2つの異なるタイプの
アクセサリを定義しています。しかし、動的フィールドにより、これらを単一のオブジェクトに
一緒に格納できます。両方のオブジェクトは`vector<u8>`（バイト文字列リテラル）を介して
`Character`にアタッチされ、それぞれの名前を使用してアクセスできます。

ご覧のとおり、アクセサリをCharacterにアタッチしたとき、それらを_値で_渡しました。
言い換えれば、両方の値は新しいスコープに移動し、その所有権は`Character`オブジェクトに
移転されました。`Character`オブジェクトの所有権を変更した場合、アクセサリも一緒に移動します。

そして、動的フィールドの最後の重要な特性として強調すべきは、それらが_親を通してアクセスされる_
ことです。これは、`Hat`と`Mustache`オブジェクトが直接アクセス可能ではなく、
親オブジェクトと同じルールに従うことを意味します。

## 動的フィールドとしての外部型

動的フィールドにより、オブジェクトは他のモジュールで定義されたものを含む任意の型のデータを
運ぶことができます。これは、ジェネリックな性質と型パラメータに対する比較的弱い制約により
可能です。`Character`オブジェクトにいくつかの異なる値をアタッチしてこれを説明しましょう。

```move file=packages/samples/sources/programmability/dynamic-fields.move anchor=foreign_types

```

この例では、動的フィールドの_name_と_value_の両方に異なる型をどのように使用できるかを
示しました。`String`は`vector<u8>`名を介してアタッチされ、`u64`は`u32`名を介してアタッチされ、
`bool`は`bool`名を介してアタッチされます。動的フィールドでは何でも可能です！

## 孤立した動的フィールド

> 孤立した動的フィールドを防ぐために、[Dynamic Collection Types](./dynamic-collections)の
> `Bag`などを使用してください。これらは動的フィールドを追跡し、
> アタッチされたフィールドがある場合はアンパックを許可しません。

UIDを削除するために使用される`object::delete()`関数は、動的フィールドを追跡せず、
動的フィールドが孤立することを防ぐことができません。親UIDが削除されると、
動的フィールドは自動的に削除されず、孤立します。これは、動的フィールドがまだ
ブロックチェーンに格納されているが、二度とアクセスできなくなることを意味します。

```move file=packages/samples/sources/programmability/dynamic-fields.move anchor=orphan_fields

```

孤立したオブジェクトはストレージリベートの対象ではなく、ストレージ料金は未請求のままです。
オブジェクトのアンパック中に孤立した動的フィールドを避ける一つの方法は、`UID`を返し、
動的フィールドが適切に削除および処理されるまで一時的にどこかに格納することです。

## フィールド名としてのカスタム型

上記の例では、必要なアビリティセットを持っているため、プリミティブ型をフィールド名として
使用しました。しかし、カスタム型をフィールド名として使用すると、動的フィールドはさらに
興味深くなります。これにより、データを格納するより構造化された方法が可能になり、
他のモジュールからフィールド名にアクセスされることを防ぐこともできます。

```move file=packages/samples/sources/programmability/dynamic-fields.move anchor=custom_type

```

上記で定義した2つのフィールド名は`AccessoryKey`と`MetadataKey`です。`AccessoryKey`には
`String`フィールドが含まれているため、異なる`name`値で複数回使用できます。
`MetadataKey`は空のキーで、一度だけアタッチできます。

```move file=packages/samples/sources/programmability/dynamic-fields.move anchor=custom_type_usage

```

ご覧のとおり、カスタム型はフィールド名として機能しますが、モジュールによって_構築_できる限り、
つまり、モジュールに_内部_であり、その中で定義されている場合に限ります。
構造体パッキングのこの制限は、アプリケーションの設計において新しい方法を開くことができます。

このアプローチはObject Capability<!--[]](./object-capability)-->パターンで使用され、
アプリケーションが他のモジュールにケーパビリティを公開することなく、
外部オブジェクトにその中で操作を実行することを許可できます。

## UIDの公開

<div class="warning">

`UID`への可変アクセスはセキュリティリスクです。型の`UID`を可変参照として公開すると、
オブジェクトの動的フィールドの不要な変更や削除につながる可能性があります。さらに、
Transfer to Object<!--[](./../storage/transfer-to-object)-->と
[Dynamic Object Fields](./dynamic-object-fields)に影響します。`UID`を可変参照として公開する前に、
その影響を理解してください。

</div>

動的フィールドは`UID`にアタッチされているため、他のモジュールでの使用は`UID`に
アクセスできるかどうかに依存します。デフォルトでは、構造体の可視性が`id`フィールドを保護し、
他のモジュールが直接アクセスすることを許可しません。しかし、`UID`への参照を返す
パブリックアクセサメソッドがある場合、動的フィールドは他のモジュールで読み取ることができます。

```move file=packages/samples/sources/programmability/dynamic-fields.move anchor=exposed_uid

```

上記の例では、`Character`オブジェクトの`UID`を公開する方法を示しています。このソリューションは
一部のアプリケーションで機能する可能性がありますが、公開された`UID`はオブジェクトに
アタッチされた_任意の_動的フィールドの読み取りを許可することを覚えておくことが重要です。

パッケージ内でのみ`UID`を公開する必要がある場合は、`public(package)`のような制限的な可視性を
使用するか、さらに良いのは、特定のフィールドのみの読み取りを許可するより具体的な
アクセサメソッドを使用することです。

```move file=packages/samples/sources/programmability/dynamic-fields.move anchor=exposed_uid_measures

```

## 動的フィールド vs フィールド

動的フィールドは、アクセスに追加のストレージとコストが必要なため、通常のフィールドよりも
高価です。その柔軟性には代償があり、動的フィールドと通常のフィールドの使用を決定する際に
その影響を理解することが重要です。

## 制限

動的フィールドは[オブジェクトサイズ制限](./../guides/building-against-limits)の対象ではなく、
大量のデータを格納するために使用できます。ただし、トランザクションあたり1000フィールドに
設定されている[動的フィールド作成制限](./../guides/building-against-limits)の対象となります。

## アプリケーション

動的フィールドは、任意の複雑さのアプリケーションで重要な役割を果たすことができます。
これらは、異種データの格納からアプリケーションロジックの一部としてオブジェクトを
アタッチすることまで、様々な異なるユースケースを開きます。これらは、フィールドを_後で_
定義し、フィールドの型を変更する能力に基づいて、特定の[アップグレード可能性の実践](./../guides/upgradeability-practices)を可能にします。

## 次のステップ

次のセクションでは、[Dynamic Object Fields](./dynamic-object-fields)について説明し、
動的フィールドとどのように異なるか、それらを使用することの影響について説明します。
