# 動的オブジェクトフィールド

> このセクションは[Dynamic Fields](./dynamic-fields)を拡張しています。
> 動的フィールドの基本を理解するために、まずそれを読んでください。

動的フィールドの別のバリエーションは_動的オブジェクトフィールド_で、通常の動的フィールドとは
特定の違いがあります。このセクションでは、動的オブジェクトフィールドの詳細を説明し、
通常の動的フィールドとどのように異なるかを説明します。

> 一般的な推奨事項は、特にIDを通じた直接的な発見の必要がない場合は、
> （単なる）動的フィールドを優先して動的オブジェクトフィールドの使用を避けることです。
> 動的オブジェクトフィールドの追加コストは、それらが提供する利点によって正当化されない
> 可能性があります。

## 定義

動的オブジェクトフィールドは[Sui Framework](./sui-framework)の`sui::dynamic_object_fields`モジュールで
定義されています。これらは多くの点で動的フィールドと似ていますが、動的フィールドとは異なり、
動的オブジェクトフィールドは`Value`型に追加の制約があります。`Value`は動的フィールドの場合のように
`store`だけでなく、`key`と`store`の組み合わせを持たなければなりません。

概念自体がより抽象的であるため、フレームワーク定義ではそれほど明示的ではありません：

```move
module sui::dynamic_object_field;

/// フィールドと値に関連付けられた名前を格納するために使用される内部オブジェクト。
/// 動的フィールドの直接使用とのキー衝突を防ぐために、別の型が必要です
public struct Wrapper<Name> has copy, drop, store {
    name: Name,
}
```

[Dynamic Fields](./dynamic-fields#definition)セクションの`Field`型とは異なり、`Wrapper`型は
フィールドの名前のみを格納します。値はオブジェクト自体であり、_ラップされていません_。

`Value`型の制約は、動的オブジェクトフィールドで利用可能なメソッドで明らかになります。
`add`関数のシグネチャは以下の通りです：

```move
/// オブジェクト`object: &mut UID`に`name: Name`で指定されたフィールドに
/// 動的オブジェクトフィールドを追加します。オブジェクトがすでにその名前の
/// フィールドを持っている場合は`EFieldAlreadyExists`でアボートします。
public fun add<Name: copy + drop + store, Value: key + store>(
    // アクセス制御のために複数の場所で&mut UIDを使用します
    object: &mut UID,
    name: Name,
    value: Value,
) { /* implementation omitted */ }
```

[Dynamic Fields](./dynamic-fields#usage)セクションのものと同一の残りのメソッドは、
`Value`型に同じ制約を持ちます。参考のためにリストアップします：

- `add` - オブジェクトに動的オブジェクトフィールドを追加する
- `remove` - オブジェクトから動的オブジェクトフィールドを削除する
- `borrow` - オブジェクトから動的オブジェクトフィールドを借用する
- `borrow_mut` - オブジェクトから動的オブジェクトフィールドへの可変参照を借用する
- `exists_` - 動的オブジェクトフィールドが存在するかチェックする
- `exists_with_type` - 特定の型で動的オブジェクトフィールドが存在するかチェックする

さらに、型を指定することなく`Value`オブジェクトの`ID`を返す`id`メソッドがあります。

## 使用法と動的フィールドとの違い

動的フィールドと動的オブジェクトフィールドの主な違いは、後者が値として_オブジェクトのみ_を
格納できることです。これは、`u64`や`bool`のようなプリミティブ型を格納できないことを
意味します。動的オブジェクトフィールドが別のオブジェクトに_ラップされていない_という事実が
なければ、これは制限と見なされるかもしれません。

> ラッピングの緩い要件により、オブジェクトはIDを通じてオフチェーン発見に利用可能なままです。
> ただし、ラップされたオブジェクトインデックスが実装された場合、この特性は目立たない可能性があり、
> 動的オブジェクトフィールドを冗長な機能にしてしまいます。

```move file=packages/samples/sources/programmability/dynamic-object-fields.move anchor=usage

```

## 価格の違い

動的オブジェクトフィールドは、動的フィールドよりも少し高価です。内部構造のため、
2つのオブジェクトが必要です：Name用のWrapperとValueです。このため、オブジェクトフィールドの
追加とアクセス（動的フィールドの1つと比較して2つのオブジェクトを読み込み）のコストが高くなります。

## 次のステップ

動的フィールドと動的オブジェクトフィールドの両方は、アプリケーションで革新的なソリューションを
可能にする強力な機能です。ただし、これらは比較的低レベルであり、孤立したフィールドを避けるために
注意深い処理が必要です。次のセクションでは、より効果的に動的フィールドとオブジェクトを
管理するのに役立つ高レベルな抽象化 - [Dynamic Collections](./dynamic-collections) - を紹介します。
