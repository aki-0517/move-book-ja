# パターン：ラッパー型

既存の型と同様の動作をするが、特定の変更や制限を持つ新しい型を作成する必要がある場合があります。例えば、要素が挿入された後に変更を許可しない、ベクターのように動作する[コレクション型](./collections)を作成したい場合があります。ラッパー型パターンは、これを実現する効果的な方法です。

## 定義

ラッパー型パターンは、既存の型をラップする新しい型を作成するデザインパターンです。ラッパー型は元の型とは異なりますが、それとの間で変換できます。

多くの場合、単一のフィールドを持つ位置構造体として実装されます。

```move file=packages/samples/sources/programmability/wrapper-type-pattern.move anchor=main

```

## 一般的な実践

既存の型の動作を拡張することが目標の場合、ラップされた型のアクセサを提供することが一般的です。このアプローチにより、ユーザーは必要に応じて基盤となる型に直接アクセスできます。例えば、以下のコードでは、Stack型に対して`inner()`、`inner_mut()`、`into_inner()`メソッドを提供しています。

```move file=packages/samples/sources/programmability/wrapper-type-pattern.move anchor=common

```

## 利点

ラッパー型パターンにはいくつかの利点があります：

- カスタム関数：既存の型に対してカスタム関数を定義できます。
- 堅牢な関数シグネチャ：関数シグネチャを新しい型に制約することで、コードをより堅牢にします。
- 可読性の向上：より説明的な型名を提供することで、コードの可読性を向上させることがよくあります。

## 欠点

ラッパー型パターンは、既存の型の動作を制限しながら同じデータ構造にカスタムインターフェースを提供したい場合と、既存の型の動作を拡張したい場合の2つのシナリオで強力です。しかし、いくつかの制限があります：

- 冗長性：特にラップされた型のすべてのメソッドを公開したい場合、実装が冗長になる可能性があります。
- 疎な実装：実装は非常に最小限になることがあり、多くの場合、ラップされた型への呼び出しを転送するだけです。

## 次のステップ

ラッパー型パターンは非常に有用で、特に前のセクションで示したように、コレクション型と組み合わせて使用する場合に特に有効です。次のセクションでは、[動的コレクション](./dynamic-collections)を可能にする重要なプリミティブである[動的フィールド](./dynamic-fields)について説明します。これは、より柔軟で（ただしより高価な）方法で大量のデータコレクションを保存する方法です。