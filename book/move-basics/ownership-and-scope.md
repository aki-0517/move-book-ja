# 所有権とスコープ

Moveのすべての変数にはスコープと所有者があります。スコープは変数が有効なコードの範囲であり、所有者はこの変数が属するスコープです。所有者スコープが終了すると、変数はドロップされます。これはMoveの基本的な概念であり、どのように動作するかを理解することが重要です。

<!--

- Borrow Checker
- Mention Rust's borrow checker
- Borrowing / References intro

-->

## 所有権

関数スコープで定義された変数は、このスコープによって所有されます。ランタイムは関数スコープを通過し、すべての式と文を実行します。関数スコープが終了した後、その中で定義された変数はドロップまたは割り当て解除されます。

```move
module book::ownership;

public fun owner() {
    let a = 1; // aは`owner`関数によって所有される
} // aはここでドロップされる

public fun other() {
    let b = 2; // bは`other`関数によって所有される
} // bはここでドロップされる

#[test]
fun test_owner() {
    owner();
    other();
    // a & bはここでは有効ではない
}
```

上記の例では、変数`a`は`owner`関数によって所有され、変数`b`は`other`関数によって所有されます。これらの関数のそれぞれが呼び出されると、変数が定義され、関数が終了すると、変数は破棄されます。

## 値の返却

`owner`関数を変数`a`を返すように変更すると、`a`の所有権は関数の呼び出し元に移譲されます。

```move
module book::ownership;

public fun owner(): u8 {
    let a = 1; // aはここで定義される
    a // スコープが終了し、aが返される
}

#[test]
fun test_owner() {
    let a = owner();
    // aはここで有効
} // aはここでドロップされる
```

## 値渡し

さらに、変数`a`を別の関数に渡すと、`a`の所有権はこの関数に移譲されます。この操作を実行するとき、値を一つのスコープから別のスコープに_移動_します。これは_ムーブセマンティクス_とも呼ばれます。

```move
module book::ownership;

public fun owner(): u8 {
    let a = 10;
    a
} // aが返される

public fun take_ownership(v: u8) {
    // vは`take_ownership`によって所有される
} // vはここでドロップされる

#[test]
fun test_owner() {
    let a = owner();
    // `u8`はコピー可能なので、関数呼び出し時に`move a`を渡して所有権の移譲を強制する
    take_ownership(move a);
    // aはここでは有効ではない
}
```

## ブロックによるスコープ

各関数にはメインスコープがあり、ブロックの使用によってサブスコープも持つことができます。ブロックは文と式の列であり、独自のスコープを持ちます。ブロックで定義された変数はこのブロックによって所有され、ブロックが終了すると、変数はドロップされます。

```move
module book::ownership;

public fun owner() {
    let a = 1; // aは`owner`関数のスコープによって所有される
    {
        let b = 2; // bを宣言するブロックがそれを所有する
        {
            let c = 3; // cを宣言するブロックがそれを所有する
        }; // cはここでドロップされる
    }; // bはここでドロップされる
    // a = b; // エラー: bはここでは有効ではない
    // a = c; // エラー: cはここでは有効ではない
} // aはここでドロップされる
```

ただし、ブロックから値を返すと、変数の所有権はブロックの呼び出し元に移譲されます。

```move
module book::ownership;

public fun owner(): u8 {
    let a = 1; // aは`owner`関数のスコープによって所有される
    let b = {
        let c = 2; // cを宣言するブロックがそれを所有する
        c // cはブロックから返され、bに移譲される
    };
    a + b // aとbの両方がここで有効
}
```

## コピー可能な型

Moveの一部の型は_コピー可能_です。つまり、所有権を移譲することなくコピーできます。これは、整数やブール値など、小さくてコピーのコストが安い型に有用です。Moveコンパイラは、これらの型が関数に渡されたり関数から返されたりするとき、または別のスコープに_移動_されてから元のスコープでアクセスされるときに、自動的にこれらの型をコピーします。

## 参考文献

- Move Referenceの[Local Variables and Scopes](./../../reference/variables)。
